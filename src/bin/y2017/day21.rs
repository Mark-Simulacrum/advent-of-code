use std::fmt;
use fnv::FnvHashMap as HashMap;
use std::rc::Rc;

use advent_of_code::{BitVec, Matrix};

#[derive(Hash, Clone, PartialEq, Eq)]
struct Grid {
    matrix: Matrix<bool, BitVec>,
    size: usize,
    iterations: usize,
}

impl fmt::Debug for Grid {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self.matrix)
    }
}

impl Grid {
    fn new(size: usize) -> Grid {
        Grid {
            matrix: Matrix::new(size, size),
            size: size,
            iterations: 0,
        }
    }

    fn interpret(pattern: &str) -> Grid {
        let matrix = Matrix::interpret(pattern, false, true);
        assert_eq!(matrix.columns(), matrix.rows());
        Grid {
            size: matrix.columns(),
            matrix,
            iterations: 0,
        }
    }

    fn reversed_rows(&self) -> Grid {
        let mut a = self.clone();
        a.matrix.reverse_rows();
        a
    }

    fn step(&self, rules_2: &Rules, rules_3: &Rules) -> Grid {
        if self.size % 2 == 0 {
            self.step_n(2, rules_2)
        } else {
            debug_assert!(self.size % 3 == 0);
            self.step_n(3, rules_3)
        }
    }

    fn step_n(&self, n: usize, rules: &Rules) -> Grid {
        let mut next = Grid::new(self.size + (self.size / n));
        next.iterations = self.iterations + 1;
        let mut grid = Grid::new(n);
        for row in 0..(self.size / n) {
            for col in 0..(self.size / n) {
                let idx = row * n * self.size + col * n;
                grid.matrix.load_from(idx, &self.matrix);
                let out = &rules[&grid];
                let m = n + 1;
                let s = next.size;
                next.matrix.set_from(row * m * s + col * m, &out.matrix);
            }
        }
        next
    }
}

type Rules = HashMap<Grid, Rc<Grid>>;

fn eval(s: &str, iterations: usize) -> u32 {
    let mut rules_2 = HashMap::default();
    let mut rules_3 = HashMap::default();
    for line in s.trim().lines() {
        let mut parts = line.split(" => ");
        let mut pattern = Grid::interpret(parts.next().unwrap());
        let output = Rc::new(Grid::interpret(parts.next().unwrap()));
        let mut patterns = Vec::with_capacity(8);
        patterns.push(pattern.clone());
        patterns.push(pattern.reversed_rows());
        pattern.matrix.rotate_90(); // 90
        patterns.push(pattern.clone());
        patterns.push(pattern.reversed_rows());
        pattern.matrix.rotate_90(); // 180
        patterns.push(pattern.clone());
        patterns.push(pattern.reversed_rows());
        pattern.matrix.rotate_90(); // 270
        patterns.push(pattern.clone());
        patterns.push(pattern.reversed_rows());
        let mut map = if patterns[0].size == 2 {
            &mut rules_2
        } else {
            &mut rules_3
        };
        for pattern in patterns {
            map.insert(pattern, output.clone());
        }
    }
    let mut grid = Grid::interpret(INITIAL_PATTERN.trim());
    while grid.iterations < iterations {
        grid = grid.step(&rules_2, &rules_3);
    }
    grid.matrix.count_set()
}

pub fn part1(s: &str) -> u32 {
    eval(s, 5)
}

pub fn part2(s: &str) -> u32 {
    eval(s, 18)
}

#[test]
fn part1_actual() {
    assert_eq!(part1(INPUT), 176);
}

#[test]
fn part2_actual() {
    assert_eq!(part2(INPUT), 2368161);
}

static INITIAL_PATTERN: &str = "
.#.
..#
###
";

pub static INPUT: &str = "
../.. => .#./.../###
#./.. => .#./##./#..
##/.. => #.#/#../###
.#/#. => ##./..#/###
##/#. => .#./#../..#
##/## => #../..#/#.#
.../.../... => .###/.#.#/.###/##.#
#../.../... => .##./##../##../#.##
.#./.../... => .#.#/#.#./..#./..#.
##./.../... => ###./#.##/...#/#.##
#.#/.../... => .#.#/.#../.###/.###
###/.../... => ..##/#.#./..../##.#
.#./#../... => #.../..../..../....
##./#../... => ...#/..#./.###/#.#.
..#/#../... => #.../#.##/###./##..
#.#/#../... => .##./#..#/#..#/..##
.##/#../... => .#.#/#.##/..##/.#.#
###/#../... => #.#./.###/..#./#.#.
.../.#./... => #..#/..../.##./.#.#
#../.#./... => .#../.##./.#.#/...#
.#./.#./... => ##.#/...#/.##./...#
##./.#./... => ..#./#.#./#.##/####
#.#/.#./... => ..##/#..#/.###/....
###/.#./... => .#../#..#/#.../..#.
.#./##./... => ..##/#.#./####/###.
##./##./... => ...#/.#../####/#..#
..#/##./... => ..##/##../###./....
#.#/##./... => ..##/#.../.#../.##.
.##/##./... => #.../##../#.##/...#
###/##./... => .#../####/#.##/#.##
.../#.#/... => #..#/####/###./#.#.
#../#.#/... => #.../##.#/#.../.#..
.#./#.#/... => ##.#/##.#/..#./..#.
##./#.#/... => .###/..#./.#../.###
#.#/#.#/... => .###/##../..#./..#.
###/#.#/... => ##../.#../.#../.#..
.../###/... => ..#./#.#./..#./#..#
#../###/... => ..../#.#./##.#/..##
.#./###/... => ..#./#.#./..##/.#..
##./###/... => .##./..##/#..#/#.#.
#.#/###/... => ###./###./#.##/..##
###/###/... => ##.#/..../.##./.#..
..#/.../#.. => .###/####/..../##.#
#.#/.../#.. => ##../###./#..#/...#
.##/.../#.. => ###./#..#/###./...#
###/.../#.. => #.../#..#/##.#/.##.
.##/#../#.. => ..##/####/..##/#...
###/#../#.. => #.../..../...#/..##
..#/.#./#.. => ####/#.#./..../.#.#
#.#/.#./#.. => .##./.#.#/##.#/.##.
.##/.#./#.. => ###./.#.#/###./##.#
###/.#./#.. => #.##/..##/#.#./##.#
.##/##./#.. => ..../..##/#.#./.##.
###/##./#.. => #.#./#..#/#..#/###.
#../..#/#.. => ..../####/#..#/.###
.#./..#/#.. => .###/#.../#.../#.##
##./..#/#.. => ####/##.#/###./####
#.#/..#/#.. => .#../##.#/#..#/#..#
.##/..#/#.. => ..##/##.#/#.##/###.
###/..#/#.. => ##.#/####/##.#/.#..
#../#.#/#.. => .###/#..#/.##./.###
.#./#.#/#.. => #.##/.##./.#../..#.
##./#.#/#.. => ###./..#./.##./##..
..#/#.#/#.. => .###/.#.#/#.#./##..
#.#/#.#/#.. => #..#/.###/.##./....
.##/#.#/#.. => ###./.###/#.##/.###
###/#.#/#.. => ####/.###/..../.##.
#../.##/#.. => ##.#/..../#.../..#.
.#./.##/#.. => #.../..../...#/###.
##./.##/#.. => ###./.#../..##/...#
#.#/.##/#.. => #.../...#/..#./.###
.##/.##/#.. => ###./..../##.#/...#
###/.##/#.. => ##.#/##../###./.##.
#../###/#.. => ..#./#.../..##/#.##
.#./###/#.. => ...#/.##./.#../.#..
##./###/#.. => ##.#/.#.#/###./....
..#/###/#.. => #.##/#.../####/.##.
#.#/###/#.. => .#.#/...#/#..#/..#.
.##/###/#.. => .##./#..#/#..#/.#.#
###/###/#.. => ###./####/#.##/#...
.#./#.#/.#. => ###./#..#/...#/...#
##./#.#/.#. => #.#./#.##/#.../#..#
#.#/#.#/.#. => .#.#/#.##/..../.#..
###/#.#/.#. => #.#./.#../.###/#.#.
.#./###/.#. => #.../.###/##../##.#
##./###/.#. => .###/#.../####/.#.#
#.#/###/.#. => #..#/####/#.#./#...
###/###/.#. => .#../..../.##./.#.#
#.#/..#/##. => ##../###./...#/###.
###/..#/##. => .##./###./.###/#.##
.##/#.#/##. => ..../##.#/#..#/#...
###/#.#/##. => .###/##../..../..#.
#.#/.##/##. => ####/.###/##../...#
###/.##/##. => #.##/..##/..#./#..#
.##/###/##. => ..../#.##/#.../#.##
###/###/##. => ..../#..#/#.##/#.##
#.#/.../#.# => #.../##.#/..../.#.#
###/.../#.# => ##../##../#.#./.##.
###/#../#.# => .##./.#../#.##/.##.
#.#/.#./#.# => #.../.#../####/#.##
###/.#./#.# => .###/##.#/#.../#.#.
###/##./#.# => .##./.##./.###/.#.#
#.#/#.#/#.# => ####/####/###./.##.
###/#.#/#.# => #.#./.###/...#/.#.#
#.#/###/#.# => .###/..#./..../.##.
###/###/#.# => #.#./##.#/..#./..#.
###/#.#/### => ###./#.../##../##..
###/###/### => ##.#/.#.#/#.#./...#
";
